[{"content":"代码随想录_链表 1.链表：移除链表元素 这种情况下的移除操作，就是让节点next指针直接指向下下一个节点就可以了。\n因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？\n链表操作的两种方式：\n直接使用原来的链表来进行删除操作。 设置一个虚拟头结点在进行删除操作。 直接使用原来的链表来进行移除节点操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: ListNode* removeElements(ListNode* head, int val) { // 删除头结点 while (head != NULL \u0026amp;\u0026amp; head-\u0026gt;val == val) { // 注意这里不是if，可能头部有多个target节点 ListNode* tmp = head; head = head-\u0026gt;next; delete tmp;//注意删除 } // 删除非头结点 //主要判断的是cur-\u0026gt;next这个节点，但是需要前一个节点，所以这样进行遍历 ListNode* cur = head; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next!= NULL) {//需要判断操作head之后是否还需要操作 if (cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next;//如果不是，直接移动到下一个节点 } } return head; } }; 设置一个虚拟头结点在进行移除节点操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while (cur-\u0026gt;next != NULL) { if(cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } head = dummyHead-\u0026gt;next; delete dummyHead; return head; } }; 2.链表：设计链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class MyLinkedList { public: struct ListNode{ int val; ListNode* next; ListNode(int val):val(val),next(nullptr){} }; MyLinkedList() { _dummyhead= new ListNode(0); _size = 0; } int get(int index){ if(index\u0026lt;0||index\u0026gt;(_size-1))return -1; ListNode* cur= _dummyhead-\u0026gt;next; while(index--){ cur=cur-\u0026gt;next; } return cur-\u0026gt;val; } void addAtHead(int val) { ListNode* newhead = new ListNode(val); newhead-\u0026gt;next=_dummyhead-\u0026gt;next; _dummyhead-\u0026gt;next=newhead; _size++; } void addAtTail(int val) { ListNode* cur=_dummyhead; while(cur-\u0026gt;next!=nullptr)cur=cur-\u0026gt;next; ListNode* newnode = new ListNode(val); cur-\u0026gt;next = newnode; _size++; } void addAtIndex(int index, int val) { if(index\u0026gt;_size||index\u0026lt;0)return ;/当index==_size,插入到最后 ListNode* newnode=new ListNode(val); ListNode* cur=_dummyhead; while(index--){ cur=cur-\u0026gt;next; } newnode-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = newnode; _size++; } void deleteAtIndex(int index) { if(index\u0026gt;=_size||index\u0026lt;0)return ; ListNode* cur=_dummyhead; while(index--){ cur=cur-\u0026gt;next; } ListNode* tmp=cur-\u0026gt;next; cur-\u0026gt;next=cur-\u0026gt;next-\u0026gt;next; delete tmp; tmp=nullptr; _size--; } private: int _size; ListNode* _dummyhead; }; 2.链表：翻转链表 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。\n然后就要开始反转了，首先要把 cur-\u0026gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。\n为什么要保存一下这个节点呢，因为接下来要改变 cur-\u0026gt;next 的指向了，将cur-\u0026gt;next 指向pre ，此时已经反转了第一个节点了。\n接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。\n最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; // 保存cur的下一个节点 ListNode* cur = head; ListNode* pre = NULL; while(cur) { temp = cur-\u0026gt;next; // 保存一下 cur的下一个节点，因为接下来要改变cur-\u0026gt;next cur-\u0026gt;next = pre; // 翻转操作 // 更新pre 和 cur指针 pre = cur; cur = temp; } return pre; } }; 3.链表：两两交换链表中的节点 使用虚拟头结点,接下来就是交换相邻两个元素了，此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 shaclass Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while(cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { ListNode* tmp = cur-\u0026gt;next; // 记录临时节点 ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; // 记录临时节点 cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; // 步骤一 cur-\u0026gt;next-\u0026gt;next = tmp; // 步骤二 cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; // 步骤三 cur = cur-\u0026gt;next-\u0026gt;next; // cur移动两位，准备下一轮交换 } ListNode* result = dummyHead-\u0026gt;next; delete dummyHead; return result; } }; 4.链表：删除链表的倒数第N个节点 fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0); dummyHead-\u0026gt;next = head; ListNode* slow = dummyHead; ListNode* fast = dummyHead; while(n-- \u0026amp;\u0026amp; fast != NULL) { fast = fast-\u0026gt;next; } fast = fast-\u0026gt;next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点 while (fast != NULL) { fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; // ListNode *tmp = slow-\u0026gt;next; C++释放内存的逻辑 // slow-\u0026gt;next = tmp-\u0026gt;next; // delete tmp; return dummyHead-\u0026gt;next; } }; 5.链表：链表相交 对于这道题目，重点是判断两个链表是否是交点可以判断两个指针是否相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* t1=headA; ListNode* t2=headB; int l1=0,l2=0; while(t1!=NULL){ l1++; t1=t1-\u0026gt;next; } while(t2!=NULL){ l2++; t2=t2-\u0026gt;next; } t1=headA; t2=headB; if(l1\u0026lt;l2){ swap(l1,l2); swap(t1,t2); } int len=l1-l2; while(len--){ t1=t1-\u0026gt;next; } while(t1!=NULL\u0026amp;\u0026amp;t2!=NULL){ if(t1==t2)return t1; t1=t1-\u0026gt;next; t2=t2-\u0026gt;next; } return NULL; } }; 6.链表：环形链表 这道题很经典，使用快慢指针是很好的方法，同时需要查找交点，需要考虑一些数学性质。\n关键就是找到x的对应位置，由快慢指针的等式\n$$2(x+y)=x+y+n*(y+z)，n≥1$$则\n$$x=(n-1)*(y+z)+z$$ 那么只需要在相遇的地方和头节点设立指针进行轮转即可\n这种快慢指针思路在很多判断环存在的场景都很有用。可以去leetcode上多了解相关题目\n代码随想录\n","date":"2025-05-04T00:00:00Z","image":"https://xzxg001.github.io/p/code_with_thinkinglist/image_hu_2aa26f4f5bf6a6cd.png","permalink":"https://xzxg001.github.io/p/code_with_thinkinglist/","title":"Code_with_thinking:List"},{"content":"代码随想录_数组 1.数组：二分查找 1\u0026gt;前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，\n2\u0026gt;判断两个边界条件：\n$$while(left\u003c or \u003c=right)$$以及\n$$if(num[middle]\u003etarget)right=middle-1/middle$$循环不变量：[left,right] or [left,right)\n1 2 3 4 5 6 7 8 9 10 11 12 13 //假设left=0 right=num.size-1(包括右边界) //[] while(left\u0026lt;=right){middle=(left+right)/2 if(num[middle]\u0026gt;target)right=middle-1; else if(num[middle]\u0026lt;target)left=middle+1; else return middle; } return -1; 1 2 3 4 5 6 7 8 9 10 11 12 13 //假设left=0 right=num.size(不包括右边界) //[) while(left\u0026lt;right){middle=(left+right)/2 if(num[middle]\u0026gt;target)right=middle; else if(num[middle]\u0026lt;target)left=middle+1; else return middle; } return -1; 3\u0026gt;\n$$middle = left + ((right - left) \u003e\u003e 1);$$4\u0026gt;同学对于二分法都是一看就会，一写就废？\n其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。\n区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。\n2.数组：移除元素（双指针） 等同于vector容器中erase的操作\n1\u0026gt;暴力实现：两重for循环\n2\u0026gt;双指针解决：时间复杂度：O(n),使用快慢指针。\n快指针指向需要删除的元素，慢指针指向新数组需要的元素。主要思路是覆盖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0;//慢指针指向新数组需要的元素 for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex];//快指针指向需要删除的元素 } } return slowIndex; } }; 3.数组：有序数组的平方（双指针） 1\u0026gt;暴力排序 平方+排序 O(nlogn)\n2\u0026gt;双指针法 从两边开始不断比较两端平方的大小，放入result数组\n4.数组：长度最小的子数组（滑动窗口） 要求\n$$sum\u003e=s$$ 找到长度最小的子数组\n1\u0026gt;暴力：两重for循环，确定起始和终止位置\n2\u0026gt;滑动窗口（双指针）使用j来遍历终止位置，然后移动起始位置确定最小长度数组\n窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。\n窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int sum=0; int i=0; int ans=INT_MAX; for(int j=0;j\u0026lt;nums.size();j++){ sum+=nums[j]; while(sum\u0026gt;=target){ ans=min(ans,j-i+1); sum-=nums[i++]; } } return (ans==INT_MAX)?0:ans; } }; 当然，评论区也有人说用前缀和来做，然后用二分查找来遍历寻找，最终时间复杂度\n$$O(nlogn)$$5.数组：螺旋矩阵 1\u0026gt;循环不变量:( ] [ ) 首选[ )\n2\u0026gt;模拟顺时针画矩阵的过程:\n填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 由外向内一圈一圈这么画下去。\n其实真正解决题目的代码都是简洁的，或者有原则性的\n3\u0026gt;掌握好边界条件进行模拟即可，重点是需要理解变量的含义及定义，绕圈法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generateMatrix(int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n,vector\u0026lt;int\u0026gt;(n,0)); int offset=1; int count=1; int loop=n/2; int startx=0,starty=0; while(loop--){ int i=startx,j=starty; for(j;j\u0026lt;n-offset;j++)a[i][j]=count++; for(i;i\u0026lt;n-offset;i++)a[i][j]=count++; for(;j\u0026gt;starty;j--)a[i][j]=count++; for(;i\u0026gt;startx;i--)a[i][j]=count++; startx++; starty++; offset++; } if(n%2==1)a[n/2][n/2]=count; return a; } }; 4\u0026gt;可以通过严格控制边界，逐渐缩圈来解决\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) {//这种方法是设置了边界条件，移动完之后判断边界情况 //直到超过循环位置停止 int w=0,s=matrix.size()-1,a=0,d=matrix[0].size()-1; vector\u0026lt;int\u0026gt; ans; while(1){ for(int i=a;i\u0026lt;=d;i++)ans.push_back(matrix[w][i]); if(++w\u0026gt;s)break; for(int j=w;j\u0026lt;=s;j++)ans.push_back(matrix[j][d]); if(--d\u0026lt;a)break; for(int i=d;i\u0026gt;=a;i--)ans.push_back(matrix[s][i]); if(--s\u0026lt;w)break; for(int j=s;j\u0026gt;=w;j--)ans.push_back(matrix[j][a]); if(++a\u0026gt;d)break; } return ans; } }; ","date":"2025-04-25T00:00:00Z","image":"https://xzxg001.github.io/p/code_with_thinkingarray/image_hu_6c99229efcb8e4f3.png","permalink":"https://xzxg001.github.io/p/code_with_thinkingarray/","title":"Code_with_thinking:Array"},{"content":"网络基础编程实验(Python3) 一、实验目的： 通过本实验，学习采用Socket（套接字）设计简单的网络数据收发程序，理解应用数据包是如何通过传输层进行传送的。\n二、实验内容： ​\tSocket（套接字）是一种抽象层，应用程序通过它来发送和接收数据，就像应用程序打开一个文件句柄，将数据读写到稳定的存储器上一样。一个socket允许应用程序添加到网络中，并与处于同一个网络中的其他应用程序进行通信。一台计算机上的应用程序向socket写入的信息能够被另一台计算机上的另一个应用程序读取，反之亦然。\n​\t不同类型的socket与不同类型的底层协议族以及同一协议族中的不同协议栈相关联。现在TCP/IP协议族中的主要socket类型为流套接字（stream sockets）和数据报套接字（datagram sockets）。流套接字将TCP作为其端对端协议（底层使用IP协议），提供了一个可信赖的字节流服务。一个TCP/IP流套接字代表了TCP连接的一端。数据报套接字使用UDP协议（底层同样使用IP协议），提供了一个\u0026quot;尽力而为\u0026quot;（best-effort）的数据报服务，应用程序可以通过它发送最长65500字节的个人信息。一个TCP/IP套接字由一个互联网地址，一个端对端协议（TCP或UDP协议）以及一个端口号唯一确定。\n2.1、采用TCP进行数据发送的简单程序（python） TCP协议，传输控制协议（TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。\nTCP通信需要经过创建连接、数据传送、终止连接三个步骤。\nTCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中打电话。\n1.客户端 创建客户端的步骤如下：\n（1）导入socket模块\n（2）创建TCP套接字\n（3）建立连接(根据ip和port与服务端)\n（4）发数据\n（5）接收服务器响应\n（6）关闭套接字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/usr/bin/env python # -*- coding:utf-8 -*- import socket # 导入socket模块，用于网络通信 # 设置要连接的服务器IP地址和端口号 # 127.0.0.1 是本机地址，9999是端口号 ip_port = (\u0026#39;127.0.0.1\u0026#39;, 9999) # 创建socket对象，使用默认的TCP协议 sk = socket.socket() # 连接服务器 sk.connect(ip_port) # 向服务器发送数据，需要先编码 sk.sendall(\u0026#39;请求占领地球\u0026#39;.encode()) # 接收服务器的响应数据，最大接收1024字节 server_reply = sk.recv(1024) # 解码并打印服务器的响应 print(server_reply.decode()) # 关闭连接 sk.close() 2.服务端 创建服务端的步骤如下：\n（1）导入socket模块\n（2）创建TCP套接字\n（3）绑定ip和port\n（4）设置为被动监听模式，最大并发接收的数量是5(设置监听模式才能是服务器)\n（5）等待接收连接请求，接收到的是一个元组 （客户端的socket对象，客户端地址)\n（6）接收并打印客户端发送的数据，并向客户端发送响应数据\n（7）关闭套接字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env python # -*- coding:utf-8 -*- import socket # 导入socket模块，用于网络通信 # 设置服务器IP地址和端口号 # 127.0.0.1 是本机地址(回环地址)，9999是端口号 ip_port = (\u0026#39;127.0.0.1\u0026#39;, 9999) # 创建socket对象，使用默认的TCP协议 sk = socket.socket() # 绑定IP地址和端口号 sk.bind(ip_port) # 开始监听，参数5表示允许最大连接数 sk.listen(5) # 服务器无限循环，持续等待客户端连接 while True: print(\u0026#39;server waiting...\u0026#39;) # 打印等待信息 # accept()会等待并返回一个客户端连接 # conn是新的套接字对象，addr是连接客户端的地址 conn, addr = sk.accept() # 接收客户端发送的数据，最大接收1024字节 client_data = conn.recv(1024) # 解码并打印客户端发送的数据 print(client_data.decode()) # 向客户端发送响应数据 conn.sendall(\u0026#39;不要回答,不要回答,不要回答\u0026#39;.encode()) # 关闭当前连接 conn.close() 3.运行结果 1.服务器处于循环等待中\n2.客户端向服务器发送请求占领地球,服务器收到消息后打印出数据内容\n3.客户端收到来自服务器端的响应不要回答\n4.服务器继续循环等待\n2.2、采用UDP进行数据发送的简单程序（python） ​\tUDP——用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。\n1.客户端 创建客户端的步骤如下：\n（1）导入socket模块\n（2）创建UDP套接字\n（3）客户端根据ip和port循环向服务端发送请求\n（4）关闭套接字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/env python # -*- coding:utf-8 -*- import socket # 导入socket模块，用于网络通信 # 设置目标服务器的IP地址和端口号 # 127.0.0.1 是本机地址，9999是端口号 ip_port = (\u0026#39;127.0.0.1\u0026#39;, 9999) # 创建UDP socket对象 # AF_INET 表示使用IPv4协议 # SOCK_DGRAM 表示使用UDP协议 # 0 表示使用默认协议 sk = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0) # 客户端循环发送数据 while True: # 获取用户输入的数据并去除两端空白 inp = input(\u0026#39;数据：\u0026#39;).strip() # 如果输入\u0026#39;exit\u0026#39;则退出循环 if inp == \u0026#39;exit\u0026#39;: break # 将数据编码并发送到服务器 # sendto()方法需要指定目标地址 sk.sendto(inp.encode(), ip_port) # 关闭socket连接 sk.close() 2.服务端 创建服务端的步骤如下： （1）导入socket模块\n（2）创建UDP套接字\n（3）套接字绑定服务端ip和port\n（4）服务端循环接收来自客户端的请求，解码并打印出接收到的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python # -*- coding:utf-8 -*- import socket # 导入socket模块，用于网络通信 # 设置服务器IP地址和端口号 # 127.0.0.1 是本机地址(回环地址)，9999是端口号 ip_port = (\u0026#39;127.0.0.1\u0026#39;, 9999) # 创建UDP socket对象 # AF_INET 表示使用IPv4协议 # SOCK_DGRAM 表示使用UDP协议 # 0 表示使用默认协议 sk = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0) # 绑定服务器地址和端口 sk.bind(ip_port) # 服务器无限循环，持续接收数据 while True: # 接收UDP数据，最大接收1024字节 # UDP不需要建立连接，直接接收数据 data = sk.recv(1024) # 解码并打印接收到的数据 print(data.decode()) 3.运行结果 （1）服务端处于无限循环\n（2）客户端向服务端发送数据，hi,zlz\n（3）服务端接收到客户端发送的数据\n2.3、TCP与UDP使用套接字的异同 1.创建套接字 参数1：family（给定的套接族）一般有两种重要参数\nsocket.AF_INET（用于服务器与服务器之间的网络通信）\nsocket.AF_INET6 （基于IPV6方式的服务器与服务器之间的网络通信）\n参数2：type（套接字类型），也是一般两个类型\nsocket.SOCK_STREAM（基于TCP的流式socket通信）\nsocket.SOCK_DGRAM（基于UDP的数据报式socket通信）\n2.发送数据 UDP发送数据使用的函数为sendto，其格式为：\n参数1：表示发送数据的内容\n参数2：表示编码格式\n参数3：表示目的地ip\n参数4：表示目的地端口\n3.建立连接 UDP的服务端中不需要设置监听模式，也不需要建立连接，TCP需要不断监听，事先建立连接。\n其余数据传输内容，与基于TCP的传输一致。\n2.4、多线程\\线程池对比 ​\t当一个客户端向一个已经被其他客户端占用的服务器发送连接请求时，虽然其在连接建立后即可向服务器端发送数据，服务器端在处理完已有客户端的请求前，却不会对新的客户端作出响应。\n​\t并行服务器：可以单独处理每一个连接，且不会产生干扰。并行服务器分为两种：一客户一线程和线程池。\n​\t每个新线程都会消耗系统资源：创建一个线程将占用CPU周期，而且每个线程都自己的数据结构（如，栈）也要消耗系统内存。另外，当一个线程阻塞（block）时，将保存其状态，选择另外一个线程运行，并在上下文转换（context switch）时恢复阻塞线程的状态。随着线程数的增加，线程将消耗越来越多的系统资源。这将最终导致系统花费更多的时间来处理上下文转换和线程管理，更少的时间来对连接进行服务。那种情况下，加入一个额外的线程实际上可能增加客户端总服务时间。\n​\t我们可以通过限制总线程数并重复使用线程来避免这个问题。与为每个连接创建一个新的线程不同，服务器在启动时创建一个由固定数量线程组成的线程池（thread pool）。当一个新的客户端连接请求传入服务器，它将交给线程池中的一个线程处理。当该线程处理完这个客户端后，又返回线程池，并为下一次请求处理做好准备。如果连接请求到达服务器时，线程池中的所有线程都已经被占用，它们则在一个队列中等待，直到有空闲的线程可用。\n（1）多线程 ​\t与单线程不同之处在于每次建立起一个新的连接时，就使用threading模块创建一个新的线程，向新的线程中传入该客户端套接字的信息，并保持通信，同时该线程需要通过thread.setDaemon(True)设置为守护主线程。\n客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import socket # 导入socket模块，用于网络通信 import threading # 导入threading模块，用于多线程编程 # 定义服务器的IP地址和端口 ip_port = (\u0026#39;127.0.0.1\u0026#39;, 9998) # 定义客户端的工作函数 def work(x): # 创建一个TCP套接字 sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 连接到服务器 sk.connect(ip_port) message = \u0026#39;拔尖班\u0026#39; + str(x) + \u0026#39;号签到\u0026#39; sk.send(message.encode()) print(\u0026#39;客户端\u0026#39; + str(x) + \u0026#39;发送签到请求成功\\n\u0026#39;) data = sk.recv(1024).decode() print(\u0026#39;客户端\u0026#39; + str(x) + \u0026#39;成功签到，接收消息:\u0026#39; + data + \u0026#39;\\n\u0026#39;) # 关闭套接字连接 sk.close() print(\u0026#39;客户端\u0026#39; + str(x) + \u0026#39;断开连接成功\\n\u0026#39;) # 创建20个线程，模拟20个客户端同时签到 for i in range(20): # 创建一个线程，目标函数是work，参数是i thread = threading.Thread(target=work, args=(i,)) # 启动线程 thread.start() ​\t客户端的实现基于多线程。work为线程的工作函数，其核心功能为创建客户端套接字，使该套接字与服务器建立TCP连接，向服务器的套接字发送数据，接受服务端套接字传输的数据。客户端基于多线程实现数据发送可以有效地模拟真实生产环境下，不同PC主机向服务器发送数据的状态，从而对多线程的工作效果加以分析。\n服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import socket # 导入socket模块，用于网络通信 import threading # 导入threading模块，用于多线程编程 # 定义服务器的IP地址和端口 ip_port = (\u0026#39;127.0.0.1\u0026#39;, 9998) # 定义处理客户端请求的函数 def work(conn, addr): # 接收客户端发送的消息 data = conn.recv(1024).decode() # 从客户端接收最多1024字节的数据，并解码为字符串 print(\u0026#39;服务器接收来自:\\t\u0026#39; + str(addr) + \u0026#39;的信息,内容为:\u0026#39; + data + \u0026#39;\\n\u0026#39;) conn.send(\u0026#39;你已签到\u0026#39;.encode()) # 发送\u0026#34;你已签到\u0026#34;消息到客户端 print(\u0026#39;服务器向\u0026#39; + str(addr) + \u0026#39;回复消息\\n\u0026#39;) conn.close() print(\u0026#39;服务器与客户端:\\t\u0026#39; + str(addr) + \u0026#39;的连接关闭\\n\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sk.bind(ip_port) # 绑定服务器的IP地址和端口 # 开始监听客户端连接，最多允许5个客户端排队 sk.listen(5) print(\u0026#39;server waiting...\u0026#39;) # 打印服务器等待连接的状态 # 服务器主循环，持续等待客户端连接 while True: # 接受客户端连接 conn, addr = sk.accept() # 阻塞等待，直到有客户端连接 print(f\u0026#39;客户端:\\t\\t{addr}连接成功\\n\u0026#39;) # 打印客户端连接成功的消息 thread = threading.Thread(target=work, args=(conn, addr), daemon=True) # 启动线程 thread.start() 运行结果 客户端： 服务器端 （2）线程池 ​\t使用ThreadPoolExecutor来实例化线程池对象。传入max_workers参数来设置线程池中最多能同时运行的线程数目。\n​\t使用submit函数来提交线程需要执行的任务（函数名和参数）到线程池中，并返回该任务的抽象对象。submit()不是阻塞的，而是立即返回。通过submit函数返回的任务抽象对象，能够使用其done()方法判断任务是否结束。\n​\t通过ThreadPoolExecutor()创建了一个最大工作线程数为10的线程池。\n​\t若将服务器端线程池最大工作线程数设置为比客户端请求线程总数小，由于线程池只会维护最大工作线程数的线程进行工作，因此，当线程池的线程已满时，后到的任务需要排队等待线程池对其进行工作调度。\n客户端 ​\t和多线程的客户端完成相同的功能，所以线程池的客户端代码与多线程的相同。\n服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import socket from concurrent.futures import ThreadPoolExecutor ip_port=(\u0026#39;127.0.0.1\u0026#39;,9997) # 定义处理客户端请求的函数 def work(conn, addr): # 接收客户端发送的消息 data = conn.recv(1024).decode() # 从客户端接收最多1024字节的数据，并解码为字符串 print(\u0026#39;服务器接收来自:\\t\u0026#39; + str(addr) + \u0026#39;的信息,内容为:\u0026#39; + data + \u0026#39;\\n\u0026#39;) conn.send(\u0026#39;你已签到\u0026#39;.encode()) # 发送\u0026#34;你已签到\u0026#34;消息到客户端 print(\u0026#39;服务器向\u0026#39; + str(addr) + \u0026#39;回复消息\\n\u0026#39;) conn.close() print(\u0026#39;服务器与客户端:\\t\u0026#39; + str(addr) + \u0026#39;的连接关闭\\n\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sk.bind(ip_port) # 绑定服务器的IP地址和端口 # 开始监听客户端连接，最多允许5个客户端排队 sk.listen(5) print(\u0026#39;server waiting...\u0026#39;) # 打印服务器等待连接的状态 # 服务器主循环，持续等待客户端连接 pool=ThreadPoolExecutor(max_workers=10) while True: conn, addr = sk.accept() pool.submit(work, conn, addr) print(f\u0026#39;客户端:\\t\\t{addr}连接成功\u0026#39;) 运行结果 客户端：\n服务端：\n（3）多线程/线程池的比较 （1）线程池是在程序运行开始，创建好的n个线程，并且这n个线程挂起等待任务的到来。而多线程是在任务到来得时候进行创建，然后执行任务。\n（2）线程池中的线程执行完之后不会回收线程，会继续将线程放在等待队列中；多线程程序在每次任务完成之后会回收该线程。\n（3）由于线程池中线程是创建好的，所以在效率上相对于多线程会高很多。\n（4）线程池也在高并发的情况下有着较好的性能；不容易挂掉。多线程在创建线程数较多的情况下，很容易挂掉。\n总结：\n多线程 特点：为每个连接创建新线程，线程生命周期由程序控制。 优点：实现简单，适合少量并发。 缺点：线程过多时资源消耗大，可能导致性能下降。 线程池 特点：预先创建固定数量的线程，任务完成后线程复用。 优点：减少线程创建和销毁开销，适合高并发场景。 缺点：实现稍复杂，需管理线程数量。 使用场景：多线程适合小型应用，线程池适合大规模服务器程序。 2.5、一个简单的文件传输助手 ​\t使用TCP连接，通过选定文件路径，在客户端与服务端进行文件传输\n协议结构：\n头部：包含文件名（字符串）和文件大小（整数），使用JSON编码。 数据：文件内容的二进制数据。 客户端 提供文件路径，文件内容和文件大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import socket import os ip_port = (\u0026#39;127.0.0.1\u0026#39;, 9996) while True: try: # Create a new socket for each file transfer attempt sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sk.connect(ip_port) path = input(\u0026#39;path: \u0026#39;) # Input file path if not os.path.exists(path): # Check if file exists print(\u0026#34;文件不存在，请重新输入路径！\u0026#34;) continue if path.lower() == \u0026#39;quit\u0026#39;: # Allow user to exit by typing \u0026#39;quit\u0026#39; print(\u0026#34;退出程序\u0026#34;) break file_name = os.path.basename(path) # Get file name file_size = os.stat(path).st_size # Get file size # Construct file information string in the format \u0026#34;filename|filesize\u0026#34; Informf = f\u0026#34;{file_name}|{file_size}\u0026#34; sk.send(Informf.encode()) # Send file information to server # Wait for server confirmation confirmation = sk.recv(1024).decode() print(f\u0026#34;服务器确认: {confirmation}\u0026#34;) print(\u0026#34;准备上传文件...\u0026#34;) # Print preparing to upload message send_size = 0 # Track sent file size with open(path, \u0026#39;rb\u0026#39;) as f: # Open file in binary read mode while send_size \u0026lt; file_size: # Read remaining bytes if less than 1024 bytes are left if file_size - send_size \u0026lt; 1024: data = f.read(file_size - send_size) else: data = f.read(1024) # Read 1024 bytes at a time sk.send(data) # Send file content to server send_size += len(data) # Update sent size print(f\u0026#34;已发送: {send_size}/{file_size} 字节\u0026#34;) # Print progress print(\u0026#39;文件上传完成！\u0026#39;) # Print upload complete message # Wait for server to confirm file upload completion sk.shutdown(socket.SHUT_WR) # Signal end of sending final_confirmation = sk.recv(1024).decode() print(f\u0026#34;服务器最终确认: {final_confirmation}\u0026#34;) print(\u0026#34;文件上传成功！\u0026#34;) break # Exit loop after successful upload except ConnectionRefusedError: print(\u0026#34;无法连接到服务器，请检查服务器是否运行！\u0026#34;) break except Exception as e: print(f\u0026#34;发生错误: {e}\u0026#34;) continue finally: sk.close() # Ensure socket is closed print(\u0026#34;客户端已退出\u0026#34;) 服务端 逐步接收客户端传输过来的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import socketserver import os class MyServer(socketserver.BaseRequestHandler): def handle(self): base_path = r\u0026#39;C:\\Users\\Lenovo\\Desktop\\network\\lab2\\file_save\u0026#39; # 文件保存的目录 conn = self.request # 获取客户端连接 print(\u0026#39;connected...\u0026#39;) # 打印连接信息 # 接收文件名和文件大小 pre_data = conn.recv(1024).decode() # 接收客户端发送的文件名和文件大小 file_name, file_size = pre_data.split(\u0026#39;|\u0026#39;) # 解析文件名和文件大小 file_size = int(file_size) # 将文件大小转换为整数 # 确认接收准备 conn.sendall(f\u0026#34;{file_name}已发送\u0026#34;.encode()) # 向客户端发送确认消息 # 创建保存文件的路径 file_dir = os.path.join(base_path, file_name) # 确保目录存在 os.makedirs(base_path, exist_ok=True) # 打开文件准备写入 with open(file_dir, \u0026#39;wb\u0026#39;) as f: recv_size = 0 # 已接收的文件大小 while recv_size \u0026lt; file_size: # 循环接收文件内容 data = conn.recv(1024) # 接收文件内容 f.write(data) # 将接收到的内容写入文件 recv_size += len(data) # 更新已接收的文件大小 print(f\u0026#34;已接收: {recv_size}/{file_size} 字节\u0026#34;) # 打印接收进度 print(\u0026#39;upload successed.\u0026#39;) # 打印上传成功信息 # 创建多线程TCP服务器 instance = socketserver.ThreadingTCPServer((\u0026#39;127.0.0.1\u0026#39;, 9996), MyServer) instance.serve_forever() # 启动服务器 运行结果 ​\t首先将想要传输的文件放到file_send文件夹中，服务端读取文件后会将其存储到file_save文件夹中\n三、实验总结 ​\t通过本次实验，我掌握了使用socket实现TCP和UDP通信的基本方法，理解了两者的核心差异：TCP提供可靠传输，适合文件传输等场景；UDP速度快但不可靠，适合实时应用。此外，我学习了多线程和线程池的设计，多线程通过为每个连接分配线程提升并发能力，而线程池通过线程复用优化了资源利用，适用于高负载环境。在文件传输中，我设计了简单的协议并加入错误处理，提升了程序健壮性。这次实验让我深刻体会到网络编程中性能与可靠性的权衡，以及并发处理的实际应用价值。\n","date":"2025-04-12T00:00:00Z","image":"https://xzxg001.github.io/p/network/image_hu_93ce4317c0745d90.png","permalink":"https://xzxg001.github.io/p/network/","title":"Network Socket lab"},{"content":"快速下载huggingface模型 如何快速下载huggingface模型——全方法总结 - 知乎方法总结\n有的时候下载huggingface会出现错误，是因为网络连接相关的问题吗，因此有一些快速下载模型来解决这个问题的方法。\n方法一：网页下载 在本站搜索，并在模型主页的Files and Version中下载文件。\n方法二：huggingface-cli huggingface-cli 是 Hugging Face 官方提供的命令行工具，自带完善的下载功能。\n1. 安装依赖 1 pip install -U huggingface_hub 2. 设置环境变量 Linux\n1 export HF_ENDPOINT=https://hf-mirror.com Windows Powershell\n1 $env:HF_ENDPOINT = \u0026#34;https://hf-mirror.com\u0026#34; 建议将上面这一行写入 ~/.bashrc。\n3.1 下载模型 1 huggingface-cli download --resume-download gpt2 --local-dir gpt2 3.2 下载数据集 1 huggingface-cli download --repo-type dataset --resume-download wikitext --local-dir wikitext 可以添加 --local-dir-use-symlinks False 参数禁用文件软链接，这样下载路径下所见即所得，详细解释请见上面提到的教程。\n方法三：使用 hfd *hfd* 是本站开发的 huggingface 专用下载工具，基于成熟工具 aria2，可以做到稳定高速下载不断线。\n1. 下载hfd\n1 2 wget https://hf-mirror.com/hfd/hfd.sh chmod a+x hfd.sh 2. 设置环境变量 Linux\n1 export HF_ENDPOINT=https://hf-mirror.com Windows Powershell\n1 $env:HF_ENDPOINT = \u0026#34;https://hf-mirror.com\u0026#34; 3.1 下载模型 1 ./hfd.sh gpt2 3.2 下载数据集 1 ./hfd.sh wikitext --dataset 方法四：使用环境变量（非侵入式） 非侵入式，能解决大部分情况。huggingface 工具链会获取HF_ENDPOINT环境变量来确定下载文件所用的网址，所以可以使用通过设置变量来解决。\n1 HF_ENDPOINT=https://hf-mirror.com python your_script.py 不过有些数据集有内置的下载脚本，那就需要手动改一下脚本内的地址来实现了。\n常见问题 Q: 有些项目需要登录，如何下载？\nA：部分 Gated Repo 需登录申请许可。为保障账号安全，本站不支持登录，需先前往 Hugging Face 官网登录、申请许可，在官网这里获取 Access Token 后回镜像站用命令行下载。 部分工具下载 Gated Repo 的方法：\nhuggingface-cli： 添加--token参数\n1 huggingface-cli download --token hf_*** --resume-download meta-llama/Llama-2-7b-hf --local-dir Llama-2-7b-hf hfd： 添加--hf_username``--hf_token参数\n1 hfd meta-llama/Llama-2-7b --hf_username YOUR_HF_USERNAME --hf_token hf_*** 其余如from_pretrained、wget、curl如何设置认证 token，详见上面第一段提到的教程。\n","date":"2024-12-31T00:00:00Z","image":"https://xzxg001.github.io/p/download-from-huggingface-quickly/image_hu_90a752bd04da3dd1.png","permalink":"https://xzxg001.github.io/p/download-from-huggingface-quickly/","title":"Download from huggingface quickly"},{"content":"CLIPSelf: 视觉Transformer自蒸馏用于开放词汇的密集预测 本文我是对 CLIPSelf 论文的详细解读，该论文提出了一种创新的视觉 Transformer 自蒸馏方法，旨在解决开放词汇的密集预测任务。 CLIP (Contrastive Language-Image Pre-training) 模型凭借其强大的对齐方式在多领域任务上实现了零样本识别能力，而 CLIPSelf 则进一步扩展了这一能力，使其适用于像语义分割和目标检测这样的密集预测任务，达到了新的高性能。\n在这篇文章中，我将首先介绍CLIP模型的基础内容，接着探讨 CLIPSelf 的核心思想、技术创新点、实现方法以及其在多个基准测试上的表现。 通过自蒸馏机制，CLIPSelf 实现了从图像级别的对比学习到像素级别的密集预测的知识转移，无需额外的监督信号，同时保持了 CLIP 模型开放词汇的优势。\n这一技术对于实际应用具有重要意义，特别是在处理包含未见过类别的场景时，能够提供更加灵活和强大的视觉理解能力。\n根据这篇文章，我对多模态数据融合产生了极大的兴趣，特别是CLIP这种朴素的想法，在使用大量文本-图像对齐之后，模型具有良好的模态交互能力，但是这种能力仍然受到限制，我希望未来优化多模态数据融合架构，形成像transformer一样的模型架构。\n通过以下幻灯片，我将逐步解析 CLIPSelf 的工作原理和技术细节。\n","date":"2024-10-15T00:00:00Z","image":"https://xzxg001.github.io/p/paper/image_hu_350a693479b152fe.png","permalink":"https://xzxg001.github.io/p/paper/","title":"CLIPSelf"},{"content":"机器学习常用性能指标总结metrics ​\t在机器学习中，性能指标是衡量一个模型好坏的关键，通过衡量模型输出y_predict 和 y_true之间的某种\u0026quot;距离\u0026quot;得出的。\n​\t性能指标往往是我们做模型时的最终目标，如准确率，召回率，敏感度等等，但是性能指标常常因为不可微分，无法作为优化的loss函数，因此采用如cross-entropy, rmse等“距离”可微函数作为优化目标，以期待在loss函数降低的时候，能够提高性能指标。而最终目标的性能指标则作为模型训练过程中，作为验证集做决定(early stoping或model selection)的主要依据，与训练结束后评估本次训练出的模型好坏的重要标准。\n性能指标的分类 ​\t根据问题类型的不同，机器学习中的性能指标主要分为：回归性能指标和分类性能指标。\n回归性能指标 平均绝对误差 ​\t平均绝对误差（Mean Absolute Error，MAE），也称为 L1 损失，是最简单的损失函数之一，也是一种易于理解的评估指标。它是通过取预测值和实际值之间的绝对差值并在整个数据集中取平均值来计算的。从数学上讲，它是绝对误差的算术平均值。MAE 仅测量误差的大小，不关心它们的方向。MAE越低，模型的准确性就越高。\n优点：\n由于采用了绝对值，因此所有误差都以相同的比例加权。 如果训练数据有异常值，MAE 不会惩罚由异常值引起的高错误。 它提供了模型执行情况的平均度量。 缺点：\n有时来自异常值的大错误最终被视为与低错误相同。 在零处不可微分。许多优化算法倾向于使用微分来找到评估指标中参数的最佳值。在 MAE 中计算梯度可能具有挑战性。 1 2 3 4 5 def mean_absolute_error(true, pred): abs_error = np.abs(true - pred) sum_abs_error = np.sum(abs_error) mae_loss = sum_abs_error / true.size return mae_loss 平均偏差误差 平均偏差误差(Mean Bias Error ,MBE)是测量过程高估或低估参数值的趋势。偏差只有一个方向，可以是正的，也可以是负的。正偏差意味着数据的误差被高估，负偏差意味着误差被低估。平均偏差误差 是预测值与实际值之差的平均值。该评估指标量化了总体偏差并捕获了预测中的平均偏差。它几乎与 MAE 相似，唯一的区别是这里没有取绝对值。这个评估指标应该小心处理，因为正负误差可以相互抵消。\n优点：\n想检查模型的方向（即是否存在正偏差或负偏差）并纠正模型偏差，MBE 是一个很好的衡量标准。 缺点：\n就幅度而言，这不是一个好的衡量标准，因为误差往往会相互补偿。 它的可靠性不高，因为有时高个体错误会产生低MBE。 作为一种评估指标，它在一个方向上可能始终是错误的。 1 2 3 4 def mean_bias_error(true, pred): bias_error = true - pred mbe_loss = np.mean(np.sum(diff) / true.size) return mbe_loss 相对绝对误差 相对绝对误差（Relative Absolute Error ，RAE）是通过将总绝对误差除以平均值和实际值之间的绝对差来计算的。RAE并以比率表示。RAE的值从0到1。一个好的模型将具有接近于零的值，其中零是最佳值。\n优点：\nRAE 可用于比较以不同单位测量误差的模型。 RAE 是可靠的，因为它可以防止异常值。 1 2 3 4 5 6 def relative_absolute_error(true, pred): true_mean = np.mean(true) squared_error_num = np.sum(np.abs(true - pred)) squared_error_den = np.sum(np.abs(true - true_mean)) rae_loss = squared_error_num / squared_error_den return rae_loss 平均绝对百分比误差 平均绝对百分比误差(Mean Absolute Percentage Error ,MAPE)是通过将实际值与预测值之间的差值除以实际值来计算的。MAPE 也称为平均绝对百分比偏差，随着误差的增加而线性增加。MAPE 越小，模型性能越好。\n优点：\nMAPE与变量的规模无关，因为它的误差估计是以百分比为单位的。 所有错误都在一个共同的尺度上标准化，很容易理解。 MAPE避免了正值和负值相互抵消的问题。 缺点：\n分母值为零时，面临着“除以零”的问题。 MAPE对数值较小的误差比对数值大的误差错误的惩罚更多。 因为使用除法运算，所欲对于相同的误差，实际值的变化将导致损失的差异。 1 2 3 4 5 def mean_absolute_percentage_error(true, pred): abs_error = (np.abs(true - pred)) / true sum_abs_error = np.sum(abs_error) mape_loss = (sum_abs_error / true.size) * 100 return mape_loss 均方误差 均方误差（Mean Squared Error ，MSE）也称为 L2 损失，MSE通过将预测值和实际值之间的差平方并在整个数据集中对其进行平均来计算误差。MSE 也称为二次损失，因为惩罚与误差不成正比，而是与误差的平方成正比。平方误差为异常值赋予更高的权重，从而为小误差产生平滑的梯度。\nMSE 永远不会是负数，因为误差是平方的。误差值范围从零到无穷大。MSE 随着误差的增加呈指数增长。一个好的模型的 MSE 值接近于零。\n优点：\nMSE会得到一个只有一个全局最小值的梯度下降。 对于小的误差，它可以有效地收敛到最小值。没有局部最小值。 MSE 通过对模型进行平方来惩罚具有巨大错误的模型。 缺点：\n对异常值的敏感性通过对它们进行平方来放大高误差。 MSE会受到异常值的影响，会寻找在整体水平上表现足够好的模型。 1 2 3 4 5 def mean_squared_error(true, pred): squared_error = np.square(true - pred) sum_squared_error = np.sum(squared_error) mse_loss = sum_squared_error / true.size return mse_loss 均方根偏差 均方根偏差（Root Mean Squared Error ，RMSE）是通过取 MSE 的平方根来计算的。它测量误差的平均幅度，并关注与实际值的偏差。RMSE 值为零表示模型具有完美拟合。RMSE 越低，模型及其预测就越好。\n优点：\n易于理解，计算方便 缺点：\n建议去除异常值才能使其正常运行。 会受到数据样本大小的影响。 1 2 3 4 5 def root_mean_squared_error(true, pred): squared_error = np.square(true - pred) sum_squared_error = np.sum(squared_error) rmse_loss = np.sqrt(sum_squared_error / true.size) return rmse_loss 相对平方误差 相对平方误差(Relative Squared Error ,RSE)需要使用均方误差并将其除以实际数据与数据平均值之间的差异的平方。\n优点\n对预测的平均值和规模不敏感。 1 2 3 4 5 6 def relative_squared_error(true, pred): true_mean = np.mean(true) squared_error_num = np.sum(np.square(true - pred)) squared_error_den = np.sum(np.square(true - true_mean)) rse_loss = squared_error_num / squared_error_den return rse_loss 归一化 RMSE 归一化 RMSE 通常通过除以一个标量值来计算，它可以有不同的方式。有时选择四分位数范围可能是最好的选择，因为其他方法容易出现异常值。当您想要比较不同因变量的模型或修改因变量时，NRMSE 是一个很好的度量。它克服了尺度依赖性，简化了不同尺度模型甚至数据集之间的比较。\n1 2 3 4 5 6 def normalized_root_mean_squared_error(true, pred): squared_error = np.square((true - pred)) sum_squared_error = np.sum(squared_error) rmse = np.sqrt(sum_squared_error / true.size) nrmse_loss = rmse/np.std(pred) return nrmse_loss 分类性能指标 混淆矩阵 ​\t也叫可能性矩阵或错误矩阵。混淆矩阵是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。\nNone 预测1 预测0 合计 实际1(P) TP FN TP+FN (P) 实际0(N) FP TN FP+TN(N) 合计 TP+FP FN+TN TP+FN+FP+TN 其中T/F表示预测是否正确，P/N表示预测的label而不是实际的label\nTrue Positive（TP）：真正类。样本的真实类别是正类，并且模型识别的结果也是正类。\nFalse Negative（FN）：假负类。样本的真实类别是正类，但是模型将其识别为负类。\nFalse Positive（FP）：假正类。样本的真实类别是负类，但是模型将其识别为正类。\nTrue Negative（TN）：真负类。样本的真实类别是负类，并且模型将其识别为负类。\n准确率 $$Acc=(TP+TN)/(TP+FN+FP+TN)$$​\t即预测正确的样本比例，表示了一个分类器的区分能力，注意，这里的区分能力没有偏向于是正例还是负例，这也是Accuracy作为性能指标最大的问题所在。\n优点：简单易懂。 缺点：在类别不平衡的情况下，容易产生误导。例如，当正负样本比例极度不平衡时，模型即使预测所有样本为多数类，也可能得到较高的准确率。 精确率/查准率 $$Pre=TP/(TP+FP)$$​\t表示在所有被预测为正例的样本中，真正是正例的比例。对于数据不平衡或是当某一方数据漏掉(通常是把这样的例子作为正例)时会产生很大的代价的时候，我们需要更有效的指标作为补充。\n优点：在关注预测结果为正类时的正确性（如垃圾邮件检测）时，精确率是一个重要指标。 缺点：忽略了实际正类样本中有多少被正确预测。 召回率/查全率/敏感度 $$Recall=TP/(TP+FN)$$​\t表示在所有实际为正例的样本中，被预测为正例的比例。在医学领域中，常把患病这样的高风险类别作为正类，当漏掉正类的代价非常高，像是漏诊可能导致病人的延迟治疗，召回率就很重要。\n在医学中，必须极力降低漏诊率，而误诊(把负例判为正例)相对于漏诊的重要性就低了很多。\n优点：在关注所有正类样本都被正确识别时（如疾病检测），召回率是一个重要指标。 缺点：忽略了预测为正类的样本中有多少是错误的。 特异性 $$Specificity=TN/(FP+TN)$$​\t表示在所有实际为负的样本中，被预测为负例的比例，即有多大概率被预测出来。可以简单地将特异性理解为负例查全率。特异性在医疗中也被认为是一个重要指标，因为特异性低也就是“误诊率高”，举一个极端例子，一个分类器把所有的样本都判定成患病，此时敏感度为1，但是有特异性却很低。因此，在医学领域，特异性和敏感度是需要同时考量的。\n优点：关注负类性能，在负类重要性高的任务中（如疾病筛查中的健康人判断），特异性比准确率（Accuracy）更能反映模型对负类的识别能力。 缺点：忽略正类性能，依赖明确的负类定义，无法单独作为评估标准 Fβ_Score ​\tFβ的物理意义就是将精确率和召回率的一种加权平均，在合并的过程中，召回率的权重是精确率的β倍。常用的是F1分数（F1 Score），是统计学中用来衡量二分类模型精确度的一种指标。Accuracy和F1-Score是判断分类模型总体的标准。\nMacro-F1和Micro-F1是相对于多标签分类而言的。\nMicro-F1，计算出所有类别总的Precision和Recall，然后计算F1。\nMacro-F1，计算出每一个类的Precison和Recall后计算F1，最后将F1平均。\n​\n优点：在类别不平衡的情况下，比单独使用精确率或召回率更能全面反映模型性能。\n缺点：无法同时优化精确率和召回率的具体值。\nROC曲线和AUC ​\tROC曲线的全称叫做Receiver Operating Characteristic，常常被用来判别一个分类器的好坏程度\nx轴坐标是False positive rate，即假正率，定义为\n$$FPR=FP/(FP+TN)=1-Specificity$$，即误诊率，代表所有实际为负例的样本中，预测错误的比例。\ny轴坐标是True positive rate，即真正率，定义为\n$$TPR=TP/(TP+FN)$$,即召回率/查全率/敏感度\n现在可知，ROC的x轴是误诊率，y轴是漏诊率。\n​\tAUC，即曲线下面积（Area Under Curve），是 ROC 曲线下面积的一个数值表示。它提供了一个定量的指标，用来衡量分类模型的整体表现。AUC 值范围从 0 到 1，值越大表示模型性能越好。\n下方是具体绘制的方法\n画出ROC的曲线的方法不只是计算一次误诊率和漏诊率，按照以下方式进行：\n将分类器预测为正例的概率从小到大排序 把每两个样本间的概率作为阈值，小于该阈值的分为负例，大于的分为正例 分别计算TPR和FPR 转2 当所有阈值都被枚举完之后，获得一组(TPR, FPR)的坐标点，将它们画出来。结束 下方是具体的python代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 from sklearn.metrics import roc_curve import matplotlib.pyplot as plt p_rate = model.get_prob(X) #计算分类器把样本分为正例的概率 fpr, tpr, thresh = roc_curve(y_true, p_rate) plt.figure(figsize=(5, 5)) plt.title(\u0026#39;ROC Curve\u0026#39;) plt.xlabel(\u0026#39;False Positive Rate\u0026#39;) plt.ylabel(\u0026#39;True Positive Rate\u0026#39;) plt.grid(True) plt.plot(fpr, tpr) plt.savefig(\u0026#39;roc.png\u0026#39;) ​\t模型的ROC曲线离对角线越近，模型的准确率越低。如果模型真的很好，随着有序列表（第一张由元组标号的图）向下移动，开始就可能遇到真正例元组，图开始就陡峭地从 0 开始上升，后来遇到的真正例越来越少，假正例越来越多，曲线平缓变得更加水平。\n​\t为了评估模型的准确率，可以测量曲线下方的面积（AUC）。面积越接近 0.5 ，模型的准确率越低。完全正确的模型面积为 1.0\n优点： 兼顾正例和负例的权衡。因为TPR聚焦于正例，FPR聚焦于与负例，使其成为一个比较均衡的评估方法。 ROC曲线选用的两个指标，不受类别不平衡影响，都不依赖于具体的类别分布，全面反映模型在不同阈值下的性能。 缺点：计算复杂度较高，解释起来可能不直观。 ","date":"2024-04-04T00:00:00Z","image":"https://xzxg001.github.io/p/metrics/image_hu_c9031a76d1beff50.png","permalink":"https://xzxg001.github.io/p/metrics/","title":"Metrics"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://xzxg001.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]